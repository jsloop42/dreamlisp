(defmodule test  
  "A module to work with unit tests."
  (export all))

(defmacro deftest (name desc & form)
  "A macro to define a test case. Takes test case name, description and expressions."
  `(def ~name ^(vector :test-case) (fn () ~desc ~@form)))

(defmacro testing (desc & form)
  "A macro to evaluate individual test cases. Takes a description string and expressions."
  `(do ~@form))

(defmacro is (exp res)
  `(is ~exp ~res ""))

(defmacro is (exp res msg)
  "A macro to evaluate the given expression, `exp` and checks if the result is same as the given `res`. If the test fails `msg` is printed if given, else the
   result is printed."
  (let (ret (gensym) body (gensym))
    `(let (~ret ~exp
           ~body (quote ~exp))
      (when (not (= ~ret ~res))
        (map core:println/n (vector (str "\nexpected: " ~res) 
                                    (str "actual:   (not " ~body ")")
                                    (if (empty? ~msg) (str ~ret) ~msg)))))))

(defmacro run (module-name)
  "A test runner function which takes a string, `module-name` as its argument and executes all test functions found in the module."
  (let (info (gensym) runner (gensym) f (gensym) fn-meta (gensym) xs (gensym) caller-module (current-module-name))
    `(do
      (let (~info (:exports (module-info ~module-name))
            ~runner (fn (~xs)
                      (when-not (empty? ~xs)
                        (let (~f (first ~xs) ~fn-meta (meta ~f))
                          (when (and (not (nil? ~fn-meta)) (vector? ~fn-meta) (= (first ~fn-meta) :test-case))
                            ((eval ~f)))
                          (~runner (rest ~xs))))))
        (~runner ~info))
        (in-module ~caller-module))))
